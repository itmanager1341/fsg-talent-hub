# Cursor Rules for FSG Talent Hub

## Critical Supabase Rules

### ⚠️ ALWAYS USE SUPABASE ONLINE (NOT CLI)
- **NEVER** suggest using `supabase` CLI commands
- **ALWAYS** use MCP Supabase tools for database operations
- **ALWAYS** use MCP Supabase tools to deploy edge functions
- We use Supabase online dashboard, not local CLI

### Edge Function Deployment
- **ALWAYS** use `mcp_supabase_deploy_edge_function` to deploy edge functions
- **NEVER** suggest `supabase functions deploy` or CLI commands
- Read the edge function file, then deploy using MCP tool with file contents

### Database Migrations
- **ALWAYS** use `mcp_supabase_apply_migration` for database changes
- **NEVER** suggest running SQL manually unless explicitly requested
- Verify migrations using `mcp_supabase_list_migrations` and `mcp_supabase_list_tables`

### SQL Execution
- For one-off queries or verification, use `mcp_supabase_execute_sql`
- For schema changes, use `mcp_supabase_apply_migration`
- **NEVER** suggest running SQL in terminal or CLI

## Verification Protocol

### Before Making Claims
- ✅ **ALWAYS** use MCP tools to verify Supabase state
- ✅ **ALWAYS** search codebase for existing implementations
- ✅ **ALWAYS** read existing documentation before updating
- ✅ **NEVER** assume deployment status or database state

### When Deploying
1. Read the edge function file
2. Deploy using `mcp_supabase_deploy_edge_function`
3. Verify deployment with `mcp_supabase_list_edge_functions`
4. Test the function if possible

## Git Commands

### Avoid Timeout Issues
- **NEVER** use `git show` without `--name-only` flag
- **Use** `git log --oneline` instead of `git log`
- **Use** `git diff --name-only` to see changed files
- **Always append** `| cat` to commands that might use a pager

## Code Documentation

- Generate docstrings or comments for complex functions or classes
- Ensure newly suggested code is well-documented
- Keep commit messages succinct but informative

## General Guidelines

- Always read existing code before making changes
- Follow existing patterns and conventions
- Use TypeScript types consistently
- Handle errors gracefully with proper error messages
- Test functionality when possible

